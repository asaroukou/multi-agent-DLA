package fr.utbm.ia54.dla.agents

import javafx.geometry.Point2D
import io.sarl.lang.core.Agent
import io.sarl.core.Lifecycle
import java.util.UUID

enum Direction {
	UP,
	DOWN,
	LEFT,
	RIGHT,
	UP_LEFT,
	UP_RIGHT,
	DOWN_LEFT,
	DOWN_RIGHT
}

@SuppressWarnings("potential_field_synchronization_problem")
behavior Move extends PerceptDirection {
	var boundarie : int

	new(owner : Agent, boundarie : int) {
		super(owner)
		this.boundarie = boundarie
	}

	def move(position : Point2D, direction : Direction) : Point2D {
		var displacementPoint : Point2D = directionToPoint(direction)
		var newPosition = position.add(displacementPoint)
		if (newPosition.x < 0) {
			newPosition = new Point2D(boundarie - 1, newPosition.y)
		}
		if (newPosition.y < 0) {
			newPosition = new Point2D(newPosition.x, boundarie - 1)
		}
		newPosition = new Point2D(newPosition.x % boundarie, newPosition.y % boundarie)
		return newPosition
	}

	def randomMove(position : Point2D) : Point2D {
		var randDirection = randomDirection()
		return move(position, randDirection)
	}

}

behavior PerceptDirection {

	def mapIntToDirection(i : int) : Direction {
		return Direction.values().get(i)
	}

	def randomDirection() : Direction {
		var rand = (Math.random() * (7 + 1)) as int;
		return mapIntToDirection(rand)
	}

	def directionToPoint(direction : Direction) : Point2D {
		var point : Point2D = new Point2D(0, 0)
		switch direction {
			case UP: point = point.add(0, -1)
			case DOWN: point = point.add(0, 1)
			case LEFT: point = point.add(-1, 0)
			case RIGHT: point = point.add(1, 0)
			case UP_LEFT: point = point.add(-1, -1)
			case UP_RIGHT: point = point.add(1, -1)
			case DOWN_LEFT: point = point.add(-1, 1)
			case DOWN_RIGHT: point = point.add(1, 1)
		}
		return point
	}

	def perceptAround(position : Point2D) : Point2D[] {
		var directions = Direction.values()
		var positions : Point2D[] = newArrayOfSize(directions.length)
		var i = 0
		for (d : directions) {
			positions.set(i, position.add(directionToPoint(d)))
			i++
		}
		return positions
	}
}

behavior InitConfiguration {
	uses Lifecycle
	def drawCircle(size : int, parent : UUID, walkingRate: int) {
		var startPoint = new Point2D(size / 2 as int, size / 2 as int)
		var r = startPoint.distance(new Point2D(size / 2 as int, 4))
		var activeCount = 0
		for (x : 0 ..< size) {
			for (y : 0 ..< size) {
				var endPoint = new Point2D(x, y)
				var d = startPoint.distance(endPoint)
				if (d <= r + 0.7 && d >= r - 0.7) {
					spawn(Walker, endPoint, true, size, parent, walkingRate)
					activeCount++
				}
			}
		}
		return activeCount
	}

	def drawTopLeftBottomRight(size : int, parent : UUID, walkingRate : int) {
		var activeCount = 0
		for (x : 0 ..< size) {
			spawn(Walker, new Point2D(x, x), true, size, this.ID, walkingRate)
			activeCount++
		}
		return activeCount
	}

	def drawTopRightBottomLeft(size : int, parent : UUID, walkingRate : int) {
		var activeCount = 0
		for (x : 0 ..< size) {
			spawn(Walker, new Point2D(size - x - 1, x), true, size, this.ID, walkingRate)
			activeCount++
		}
		return activeCount
	}

	def drawBottomSide(size : int, parent : UUID, walkingRate : int) {
		var activeCount = 0
		for (x : 0 ..< size) {
			spawn(Walker, new Point2D(x, size - 1), true, size, this.ID, walkingRate)
			activeCount++
		}
		return activeCount
	}

	def drawTopSide(size : int, parent : UUID, walkingRate : int) {
		var activeCount = 0
		for (x : 0 ..< size) {
			spawn(Walker, new Point2D(x, 0), true, size, parent, walkingRate)
			activeCount++
		}
		return activeCount
	}

	def drawLeftSide(size : int, parent : UUID, walkingRate : int) {
		var activeCount = 0
		for (x : 0 ..< size) {
			spawn(Walker, new Point2D(0, x), true, size, parent, walkingRate)
			activeCount++
		}
		return activeCount
	}

	def drawRightSide(size : int, parent : UUID, walkingRate : int) {
		var activeCount = 0
		for (x : 0 ..< size) {
			spawn(Walker, new Point2D(size - 1, x), true, size, parent, walkingRate)
			activeCount++
		}
		return activeCount
	}

	def drawCenter(size : int, parent : UUID, walkingRate : int) {
		var startPoint = new Point2D(size / 2 as int, size / 2 as int)
		spawn(Walker, startPoint, true, size, parent, walkingRate)
		return 1
	}
}

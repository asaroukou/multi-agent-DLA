package fr.utbm.ia54.dla.agents

import javafx.geometry.Point2D
import io.sarl.lang.core.Agent
import io.sarl.core.Lifecycle
import java.util.UUID

/**
 * Direction Enum
 */
enum Direction {
	UP,
	DOWN,
	LEFT,
	RIGHT,
	UP_LEFT,
	UP_RIGHT,
	DOWN_LEFT,
	DOWN_RIGHT
}
/*
 * Behavior Move
 * Used to compute the next Position based to the current one
 */
@SuppressWarnings("potential_field_synchronization_problem")
behavior Move extends PerceptDirection {
	var boundarie : int

	new(owner : Agent, boundarie : int) {
		super(owner)
		this.boundarie = boundarie
	}

	def move(position : Point2D, direction : Direction) : Point2D {
		var displacementPoint : Point2D = directionToPoint(direction)
		var newPosition = position.add(displacementPoint)
		if (newPosition.x < 0) {
			newPosition = new Point2D(boundarie - 1, newPosition.y)
		}
		if (newPosition.y < 0) {
			newPosition = new Point2D(newPosition.x, boundarie - 1)
		}
		newPosition = new Point2D(newPosition.x % boundarie, newPosition.y % boundarie)
		return newPosition
	}

	def randomMove(position : Point2D) : Point2D {
		var randDirection = randomDirection()
		return move(position, randDirection)
	}

}
/**
 * Perception methods
 * Used to compuse the direct position arround
 */
behavior PerceptDirection {
	
	def mapIntToDirection(i : int) : Direction {
		return Direction.values().get(i)
	}
	
	//return a random direction
	def randomDirection() : Direction {
		var rand = (Math.random() * (7 + 1)) as int;
		return mapIntToDirection(rand)
	}

	//convert a direction to a unit 2D Point
	def directionToPoint(direction : Direction) : Point2D {
		var point : Point2D = new Point2D(0, 0)
		switch direction {
			case UP: point = point.add(0, -1)
			case DOWN: point = point.add(0, 1)
			case LEFT: point = point.add(-1, 0)
			case RIGHT: point = point.add(1, 0)
			case UP_LEFT: point = point.add(-1, -1)
			case UP_RIGHT: point = point.add(1, -1)
			case DOWN_LEFT: point = point.add(-1, 1)
			case DOWN_RIGHT: point = point.add(1, 1)
		}
		return point
	}
	
	//Return direct poision arrount
	def perceptAround(position : Point2D) : Point2D[] {
		var directions = Direction.values()
		var positions : Point2D[] = newArrayOfSize(directions.length)
		var i = 0
		for (d : directions) {
			positions.set(i, position.add(directionToPoint(d)))
			i++
		}
		return positions
	}
}


/**
 * Behavior used to init the first stuck cell of the simulator
 */
behavior InitConfiguration {
	uses Lifecycle
	
	//draw a circle inside of the environment grid
	def drawCircle(size : int, parent : UUID, walkingRate: int) {
		var startPoint = new Point2D(size / 2 as int, size / 2 as int)
		var r = startPoint.distance(new Point2D(size / 2 as int, 4))
		var activeCount = 0
		for (x : 0 ..< size) {
			for (y : 0 ..< size) {
				var endPoint = new Point2D(x, y)
				var d = startPoint.distance(endPoint)
				if (d <= r + 0.7 && d >= r - 0.7) {
					spawn(Walker, endPoint, true, size, parent, walkingRate)
					activeCount++
				}
			}
		}
		return activeCount
	}

	// init stuck cell from the top left of the environment to the bottom right
	def drawTopLeftBottomRight(size : int, parent : UUID, walkingRate : int) {
		var activeCount = 0
		for (x : 0 ..< size) {
			spawn(Walker, new Point2D(x, x), true, size, this.ID, walkingRate)
			activeCount++
		}
		return activeCount
	}

	// init stuck cell from the top right of the environment to the bottom left
	def drawTopRightBottomLeft(size : int, parent : UUID, walkingRate : int) {
		var activeCount = 0
		for (x : 0 ..< size) {
			spawn(Walker, new Point2D(size - x - 1, x), true, size, this.ID, walkingRate)
			activeCount++
		}
		return activeCount
	}

	// init a stuck cell on the bottom side
	def drawBottomSide(size : int, parent : UUID, walkingRate : int) {
		var activeCount = 0
		for (x : 0 ..< size) {
			spawn(Walker, new Point2D(x, size - 1), true, size, this.ID, walkingRate)
			activeCount++
		}
		return activeCount
	}

	// init a stuck cell on the top side
	def drawTopSide(size : int, parent : UUID, walkingRate : int) {
		var activeCount = 0
		for (x : 0 ..< size) {
			spawn(Walker, new Point2D(x, 0), true, size, parent, walkingRate)
			activeCount++
		}
		return activeCount
	}

	// init a stuck cell on the left side
	def drawLeftSide(size : int, parent : UUID, walkingRate : int) {
		var activeCount = 0
		for (x : 0 ..< size) {
			spawn(Walker, new Point2D(0, x), true, size, parent, walkingRate)
			activeCount++
		}
		return activeCount
	}
	
	//init a stuck cell on the right side
	def drawRightSide(size : int, parent : UUID, walkingRate : int) {
		var activeCount = 0
		for (x : 0 ..< size) {
			spawn(Walker, new Point2D(size - 1, x), true, size, parent, walkingRate)
			activeCount++
		}
		return activeCount
	}
	
	// init a stuck cell on the center
	def drawCenter(size : int, parent : UUID, walkingRate : int) {
		var startPoint = new Point2D(size / 2 as int, size / 2 as int)
		spawn(Walker, startPoint, true, size, parent, walkingRate)
		return 1
	}
}

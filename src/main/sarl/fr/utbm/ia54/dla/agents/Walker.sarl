package fr.utbm.ia54.dla.agents

import io.sarl.core.Behaviors
import io.sarl.core.DefaultContextInteractions
import io.sarl.core.Destroy
import io.sarl.core.Initialize
import io.sarl.core.Lifecycle
import io.sarl.core.Schedules
import fr.utbm.ia54.dla.ui.AskPercept
import fr.utbm.ia54.dla.ui.EndWalk
import fr.utbm.ia54.dla.ui.KillWalker
import fr.utbm.ia54.dla.ui.ReplyPercept
import fr.utbm.ia54.dla.ui.WalkerDie
import java.util.HashMap
import java.util.UUID
import javafx.geometry.Point2D

@SuppressWarnings("potential_field_synchronization_problem", "discouraged_occurrence_readonly_use")
agent Walker {
	uses DefaultContextInteractions, Schedules, Behaviors, Lifecycle

	var parentID : UUID
	var position : Point2D
	var stuck : boolean
	var area : Integer
	var walkingRate : Integer
	var moveBehavior : Move

	def walk(positionsAround : HashMap<Point2D, Integer>) {
		var repulsion = new Point2D(0, 0)
		for (entry : positionsAround.entrySet()) {
			if (entry.getValue() === 1) {
				repulsion = repulsion.add(entry.getKey())
			}
		}
		var nextPositions = positionsAround.filter[position, state|state == 0]
		var oldPosition = this.position
		this.position = moveBehavior.randomMove(this.position)
		if (nextPositions.containsKey(this.position) != true) {
			this.position = oldPosition
		}
		emit(new EndWalk(oldPosition, position, stuck, false))[it.UUID == this.parentID]
		if (!stuck) {
			emit(new AskPercept(this.position))[it.UUID == this.parentID]
		}
	}

	on Initialize {
		val initPosition = occurrence.parameters.get(0) as Point2D
		val isStuck = occurrence.parameters.get(1) as Boolean
		this.area = occurrence.parameters.get(2) as Integer
		this.parentID = occurrence.parameters.get(3) as UUID
		walkingRate = occurrence.parameters.get(4) as Integer
		this.stuck = isStuck as boolean
		this.moveBehavior = new Move(this, this.area)
		this.moveBehavior.registerBehavior
		if (initPosition === null) {
			var x = (Math.random() * area) as int
			var y = (Math.random() * area) as int
			this.position = new Point2D(x, y)
		} else {
			this.position = initPosition
		}
		if (!isStuck) {
			emit(new AskPercept(this.position))[it.UUID == this.parentID]
		} else {
			emit(new EndWalk(position, position, stuck, true))[it.UUID == this.parentID]
			killMe
		}
	}

	on ReplyPercept {
		occurrence.positions.forEach [ position, state |
			{
				if (state === 2) {
					this.stuck = true
				}
			}
		]
		if (!this.stuck) {
			in(walkingRate) [
				this.walk(occurrence.positions)
			]
		} else {
			emit(new EndWalk(position, position, stuck, true))[it.UUID == this.parentID]
			killMe
		}
	}

	on KillWalker {
		emit(new EndWalk(position, position, stuck, true))[it.UUID == this.parentID]
		killMe
	}

	on Destroy {
		this.moveBehavior.unregisterBehavior
		emit(new WalkerDie(this.stuck))[it.UUID == this.parentID]
	}

}

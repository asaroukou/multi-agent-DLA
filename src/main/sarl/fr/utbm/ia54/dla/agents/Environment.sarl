package fr.utbm.ia54.dla.agents

import io.sarl.core.Behaviors
import io.sarl.core.DefaultContextInteractions
import io.sarl.core.Destroy
import io.sarl.core.ExternalContextAccess
import io.sarl.core.Initialize
import io.sarl.core.Lifecycle
import io.sarl.core.Logging
import io.sarl.core.Schedules
import io.sarl.javafx.FXBehavior
import fr.utbm.ia54.dla.ui.SimulatorFxViewerController
import fr.utbm.ia54.dla.ui.PointWalker2D
import java.util.HashMap
import java.util.concurrent.atomic.AtomicInteger
import javafx.geometry.Point2D
import javafx.collections.ObservableList
import fr.utbm.ia54.dla.ui.SimulationInitConfiguration

/*
 * The main agent able to communicate with the GUI
 */
@SuppressWarnings("potential_field_synchronization_problem")
agent Environment {
	uses Behaviors, Logging, ExternalContextAccess, Lifecycle, DefaultContextInteractions, Schedules
	var envSize : Integer
	var refreshRate : Integer
	var walkingRate : Integer
	var javafxBehavior : FXBehavior
	var fxcontroller : SimulatorFxViewerController
	var walkerState : AtomicInteger[][]
	var stuckCount : AtomicInteger
	var activeCount : AtomicInteger
	var perceptDirectionBehavior : PerceptDirection
	var initConfBehavior : InitConfiguration
	
	on Initialize {
		info("agent initialized")
		fxcontroller = occurrence.parameters.get(0) as SimulatorFxViewerController
		// The agent learns how to use the UI, Perception and Configuration with a new behavior.
		this.javafxBehavior = new FXBehavior(this, fxcontroller)
		this.javafxBehavior.registerBehavior

		this.perceptDirectionBehavior = new PerceptDirection(this)
		this.perceptDirectionBehavior.registerBehavior

		this.initConfBehavior = new InitConfiguration(this)
		this.initConfBehavior.registerBehavior
		// Query the UI to refresh itself
		javafxBehavior.UISpace.emit(new Ready)
		
		//set initials metrics
		stuckCount = new AtomicInteger(0)
		activeCount = new AtomicInteger(0)
	}
	
	
	
	on RunSimulation {
		this.envSize = occurrence.envSize as Integer
		this.refreshRate = occurrence.refreshRate as Integer
		this.walkingRate = occurrence.walkingRate as Integer
		var initConf = occurrence.initConf as ObservableList<Integer>
		this.walkerState = newArrayOfSize(this.envSize, this.envSize)
		for (x : 0 ..< envSize) {
			for (y : 0 ..< envSize) {
				this.walkerState.set(x, y, new AtomicInteger(0))
			}
		}
		//Request a UI refresh every X milliseconds
		task("refesh_ui").every(refreshRate) [
			javafxBehavior.UISpace.emit(new Refresh)
		]
		//if no initial configuration for stuck cell, init in the center
		if (initConf.isEmpty) {
			var newAgentNbr = this.initConfBehavior.drawCenter(envSize, this.ID, refreshRate)
			activeCount.addAndGet(newAgentNbr)
		}
		//for all configuration, init the right way the stuck cells
		initConf.forEach[index|{
			var newAgentNbr = 0
			switch index {
				case SimulationInitConfiguration.CENTER.ordinal:
					newAgentNbr = this.initConfBehavior.drawCenter(envSize, this.ID, refreshRate)
				case SimulationInitConfiguration.TOP.ordinal:
					newAgentNbr = this.initConfBehavior.drawTopSide(envSize, this.ID, refreshRate)
				case SimulationInitConfiguration.BOTTOM.ordinal:
					newAgentNbr = this.initConfBehavior.drawBottomSide(envSize, this.ID, refreshRate)
				case SimulationInitConfiguration.LEFT.ordinal:
					newAgentNbr = this.initConfBehavior.drawLeftSide(envSize, this.ID, refreshRate)
				case SimulationInitConfiguration.RIGHT.ordinal:
					newAgentNbr = this.initConfBehavior.drawRightSide(envSize, this.ID, refreshRate)
				case SimulationInitConfiguration.TOP_LEFT_BOTTOM_RIGHT.ordinal:
					newAgentNbr = this.initConfBehavior.drawTopLeftBottomRight(envSize, this.ID, refreshRate)
				case SimulationInitConfiguration.TOP_RIGHT_BOTTOM_LEFT.ordinal:
					newAgentNbr = this.initConfBehavior.drawTopRightBottomLeft(envSize, this.ID, refreshRate)
				case SimulationInitConfiguration.CIRCLE.ordinal:
					newAgentNbr = this.initConfBehavior.drawCircle(envSize, this.ID, refreshRate)
			}
			activeCount.addAndGet(newAgentNbr)
		}]
		info("end spwan")
	}
	
	//Spawn new walker on event occure
	on SpawnRequest {
		var number = occurrence.number as int
		for (i : 0 ..< number) {
			activeCount.incrementAndGet
			spawn(Walker, null, false, envSize, this.ID, walkingRate)
		}
	}
	
	on EndWalk {
		var x = occurrence.oldPosition.getX() as int
		var y = occurrence.oldPosition.getY() as int
		this.walkerState.set(x, y, new AtomicInteger(0))
		x = occurrence.newPosition.getX() as int
		y = occurrence.newPosition.getY() as int

		if (occurrence.stuck !== true) {
			if (occurrence.shouldDie) {
				this.walkerState.set(x, y, new AtomicInteger(0))
				this.fxcontroller.removeCell(occurrence.source.UUID.toString())
			} else {
				this.walkerState.set(x, y, new AtomicInteger(1))
				this.fxcontroller.addCell(occurrence.source.UUID.toString(),
					new PointWalker2D(occurrence.newPosition, occurrence.stuck))
			}
		} else {
			this.walkerState.set(x, y, new AtomicInteger(2))
			this.fxcontroller.addCell(occurrence.source.UUID.toString(),
				new PointWalker2D(occurrence.newPosition, occurrence.stuck))
		}
	}

	on AskPercept {
		var around : HashMap<Point2D, Integer> = new HashMap<Point2D, Integer>()
		var positionAround: Point2D[] = perceptDirectionBehavior.perceptAround(occurrence.position)
		for(p: positionAround) {
			if (p.x >= 0 && p.x < envSize && p.y >= 0 && p.y < envSize) {
				var key = this.walkerState.get(p.x as int, p.y as int)
				around.put(p, key.get())
			}
		}
		emit(new ReplyPercept(around))[it.UUID == occurrence.source.UUID]
	}

	on WalkerDie {
		var stuck = occurrence.stuck as boolean
		if (stuck) {
			this.fxcontroller.setStuckMetrics(stuckCount.incrementAndGet)
		}
		this.fxcontroller.setActiveMetrics(activeCount.decrementAndGet)
	}
	
	on StopSimulation {
		emit(new KillWalker)
		task("refesh_ui").cancel() //cancel UI refresh task
		
		// every 500ms, check if all Walker died. If so, we can dispose the environment
		task("die").every(500) [
			if (activeCount.get == 0) {
				task("die").cancel()
				killMe
			}
		]
	}
	
	
	//actions after the environment has been destroyed
	on Destroy {
		javafxBehavior.UISpace.emit(new StopSimulationAck)
		this.javafxBehavior.unregisterBehavior
		this.perceptDirectionBehavior.unregisterBehavior
	}

}




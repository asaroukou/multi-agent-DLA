package io.sarl.template.javafx.agents

import io.sarl.core.Behaviors
import io.sarl.core.ExternalContextAccess
import io.sarl.core.Initialize
import io.sarl.javafx.FXBehavior
import io.sarl.template.javafx.ui.Refresh
import io.sarl.core.Logging
import javafx.geometry.Point2D

import io.sarl.template.javafx.ui.MyAppFxViewerController
import io.sarl.template.javafx.agents.Behaviors.*

import io.sarl.core.Lifecycle
import io.sarl.core.DefaultContextInteractions
import io.sarl.template.javafx.ui.EndWalk
import io.sarl.template.javafx.ui.StartWalk
import io.sarl.core.Schedules
import io.sarl.lang.core.Agent
import io.sarl.template.javafx.ui.ReplyPercept
import io.sarl.template.javafx.ui.AskPercept
import java.util.HashMap
import io.sarl.template.javafx.ui.PointWalker2D
import io.sarl.core.AgentKilled
import java.util.UUID
import java.util.concurrent.atomic.AtomicInteger

/*
 * The main agent able to communicate with the GUI
 */
@SuppressWarnings("potential_field_synchronization_problem")
	agent MyAgent {

	uses Behaviors, Logging, ExternalContextAccess, Lifecycle, DefaultContextInteractions, Schedules
	var envSize = new Integer(110)
	var javafxBehavior : FXBehavior
	var fxcontroller : MyAppFxViewerController
	var walkerState : AtomicInteger[][]
	var perceptDirectionBehavior : PerceptDirection
	def getGridNum(x : int, y : int, tileAmount : int) {
		return tileAmount * x + y
	}

	def drawCircle(startPoint:Point2D) {
		for (x : 0 ..< envSize) {
			for (y : 0 ..< envSize) {
				var endPoint = new Point2D(x, y)
				var d = startPoint.distance(endPoint)
				if (d <= 70 && d >= 69) {
					spawn(Walker, endPoint, true, envSize, this.ID)
				}
				if (d < 0) {
					info("bad")
				}
			}
		}
	}
	
	def drawLeftTopRightBottom(size : int) {
		for (x : 0 ..< size) {
			spawn(Walker, new Point2D(x, x), true, size, this.ID)
		}
	}
	
	def drawRightTopLeftBottom(size : int) {
		for (x : 0 ..< size) {
			spawn(Walker, new Point2D(size - x - 1, x), true, size, this.ID)
		}
	}

	def drawBottomSide(size: int) {
		for (x : 0 ..< size) {
			spawn(Walker, new Point2D(x, size - 1), true, size, this.ID)
		}
	}

	def drawTopSide(size : int) {
		for (x : 0 ..< size) {
			spawn(Walker, new Point2D(x, 0), true, size, this.ID)
		}
	}

	def drawLeftSide(size : int) {
		for (x : 0 ..< size) {
			spawn(Walker, new Point2D(0, x), true, size, this.ID)
		}
	}

	def drawRightSide(size : int) {
		for (x : 0 ..< size) {
			spawn(Walker, new Point2D(size - 1, x), true, size, this.ID)
		}
	}

	def drawCenter(size: int) {
		var startPoint = new Point2D(size/2 as int, size/2 as int)
		spawn(Walker, startPoint, true, envSize, this.ID)
	}
	
	on Initialize {
		info("agent initialized")
		this.walkerState = newArrayOfSize(this.envSize, this.envSize)

		for (x : 0 ..< envSize) {
			for (y : 0 ..< envSize) {
				this.walkerState.set(x, y, new AtomicInteger(0))
			}
		}
		
		fxcontroller = occurrence.parameters.get(0) as MyAppFxViewerController
		
		// The agent learns how to use the UI with a new behavior.
		// This new behavior needs to have a reference to the JavaFX controller
		this.javafxBehavior = new FXBehavior(this, fxcontroller)
		this.javafxBehavior.registerBehavior
		
		this.perceptDirectionBehavior = new PerceptDirection(this)
		this.perceptDirectionBehavior.registerBehavior
		// Query the UI to refresh itself
		// javafxBehavior.UISpace.emit(new Refresh)
		
		
		task("go").in(4000) [
 		info("start spawn")


//			this.drawBottomSide(envSize)
//			this.drawTopSide(envSize)
//			this.drawLeftSide(envSize)
//			this.drawRightSide(envSize)
//			this.drawLeftTopRightBottom(envSize)
//			this.drawRightTopLeftBottom(envSize)
			this.drawCenter(envSize)
			for (i : 0 ..<600) {
				spawn(Walker, null, false, envSize, this.ID)
			}	
			task("go").cancel()
			info("stop spwan")
		]
//		
		task("refesh_ui").every(400) [
			javafxBehavior.UISpace.emit(new Refresh)
		]
		

	}
		
	on EndWalk {
		var x = occurrence.oldPosition.getX() as int
		var y = occurrence.oldPosition.getY() as int
		this.walkerState.set(x, y, new AtomicInteger(0))
		x = occurrence.newPosition.getX() as int
		y = occurrence.newPosition.getY() as int
		if (occurrence.stuck !== true) {
			if(this.walkerState.get(x, y).get() === 1){
				
			}
			this.walkerState.set(x, y, new AtomicInteger(1))
		} else {
			this.walkerState.set(x, y, new AtomicInteger(2))
//			spawn(Walker, null, false, envSize, this.ID)
		}
		this.fxcontroller.addCell(occurrence.source.UUID.toString(),
			new PointWalker2D(occurrence.newPosition, occurrence.stuck))
	}

	on AskPercept {
		var around : HashMap<Point2D, Integer> = new HashMap<Point2D, Integer>()
		var positionAround: Point2D[] = perceptDirectionBehavior.perceptAround(occurrence.position)
		for(p: positionAround) {
			if (p.x >= 0 && p.x < envSize && p.y >= 0 && p.y < envSize) {
				var key = this.walkerState.get(p.x as int, p.y as int)
				around.put(p, key.get())
			}
		}
		emit(new ReplyPercept(around))[it.UUID == occurrence.source.UUID]
	}

}

@SuppressWarnings("potential_field_synchronization_problem", "discouraged_occurrence_readonly_use")
agent Walker {
	uses DefaultContextInteractions, Schedules, Behaviors, Logging, Lifecycle
	
	var parentID: UUID
	var position : Point2D
	var stuck : boolean
	var area : Integer
	var moveBehavior : Move
	def walk(positionsAround : HashMap<Point2D, Integer>) {
//		info("walk")
		var repulsion = new Point2D(0, 0)
		for (entry : positionsAround.entrySet()) {
			if (entry.getValue() === 1) {
				repulsion = repulsion.add(entry.getKey())
			}
		}
		var nextPositions = positionsAround.filter[position, state|state==0]
		var oldPosition = this.position
		this.position = moveBehavior.randomMove(this.position)
		if (nextPositions.containsKey(this.position) != true) {
			this.position = oldPosition
		}
		emit(new EndWalk(oldPosition, position, stuck))[it.UUID == this.parentID]
		if (!stuck){
			emit(new AskPercept(this.position))[it.UUID == this.parentID]
		}
	}

	on Initialize {
		val initPosition = occurrence.parameters.get(0) as Point2D
		val isStuck = occurrence.parameters.get(1) as Boolean
		this.area = occurrence.parameters.get(2) as Integer
		this.parentID = occurrence.parameters.get(3) as UUID
		this.stuck = isStuck as boolean
		if (initPosition === null) {
			var x = (Math.random() * area) as int
			var y = (Math.random() * area) as int
			this.position = new Point2D(x, y)
		} else {
			this.position = initPosition
		}
		if (!isStuck) {
			this.moveBehavior = new Move(this, this.area)
			this.moveBehavior.registerBehavior
			emit(new AskPercept(this.position))[it.UUID == this.parentID]
		} else {
			emit(new EndWalk(position, position, stuck))[it.UUID == this.parentID]
		}
	}
	
	on ReplyPercept {
		occurrence.positions.forEach [ position, state |{
				if (state === 2) {
					this.stuck = true
				}
			}
		]
		if (!this.stuck) {
			in(50) [
				this.walk(occurrence.positions)
			]
		} else {
			emit(new EndWalk(position, position, stuck))[it.UUID == this.parentID]
			killMe
		}
	}
	
	on Refresh {
		info("refresh")
	}
	
}

enum Direction {
	UP,
	DOWN,
	LEFT,
	RIGHT,
	UP_LEFT,
	UP_RIGHT,
	DOWN_LEFT,
	DOWN_RIGHT
}

@SuppressWarnings("potential_field_synchronization_problem")
behavior Move extends PerceptDirection {
	var boundarie : int

	new(owner : Agent, boundarie : int) {
		super(owner)
		this.boundarie = boundarie
	}

	def move(position : Point2D, direction : Direction) : Point2D {
		var displacementPoint : Point2D = directionToPoint(direction)
		var newPosition = position.add(displacementPoint)
		if (newPosition.x < 0) {
			newPosition = new Point2D(boundarie - 1, newPosition.y)
		}
		if (newPosition.y < 0) {
			newPosition = new Point2D(newPosition.x, boundarie - 1)
		}
		newPosition = new Point2D(newPosition.x % boundarie, newPosition.y % boundarie)
		return newPosition
	}

	def randomMove(position : Point2D) : Point2D {
		var randDirection = randomDirection()
		return move(position, randDirection)
	}

}


behavior PerceptDirection {

	def mapIntToDirection(i : int) : Direction {
		return Direction.values().get(i)
	}
	
	def randomDirection() : Direction {
		var rand = (Math.random() * (7 + 1)) as int;
		return mapIntToDirection(rand)
	}
	
	def directionToPoint(direction : Direction) : Point2D {
		var point : Point2D = new Point2D(0, 0)
		switch direction {
			case UP: point = point.add(0, -1)
			case DOWN: point = point.add(0, 1)
			case LEFT: point = point.add(-1, 0)
			case RIGHT: point = point.add(1, 0)
			case UP_LEFT: point = point.add(-1, -1)
			case UP_RIGHT: point = point.add(1, -1)
			case DOWN_LEFT: point = point.add(-1, 1)
			case DOWN_RIGHT: point = point.add(1, 1)
		}
		return point
	}
	
	def perceptAround(position : Point2D) : Point2D[] {
		var directions = Direction.values()
		var positions : Point2D[] = newArrayOfSize(directions.length)
		var i =0
		for (d : directions) {
			positions.set(i, position.add(directionToPoint(d)))
			i++
		}
		return positions
	}
	
	
}


